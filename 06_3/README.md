### Usage

```
$ echo -n "<number>" > /dev/my_pulse_pwm_driver
```

where `<number>` is the number of ms representing the duration of the whole brightness cycle of the LED.

### Notes on timings

A 1 ms `PWM_PERIOD` is small enough for the human eye to not perceive the abrupt transition between the ON time and the OFF time of the LED.

It absolutely does not make sense to update the *duty cycle* more than one time for each `PWM_PERIOD`. The updates would be unuseful, because they would shrink or enlarge the current square wave, while it is being produced. Instead, a *duty cycle* change should affect the next square wave(s).

The CPU occupation with the previous parameters (with `100` for `PWM_DEFAULT_STEPS_PER_MS` and, correspondingly, `10` ms as `PWM_DEFAULT_DELAY`), moreover, was at 100 % during the whole brightness cycle of the LED; it was due to the very frequent calls to `duty_cycle_change`, but maybe also to the frequent interrupts generated by `udelay` (as specified in the [kernel document](https://www.kernel.org/doc/html/latest/timers/timers-howto.html)). If the brightness cycle was repeated in a continuous loop, the Raspberry would become unusable: the system loads would increase uncontrollably.

With this code, the resolution of the *duty cycle* updates is constant (1 per `PWM_PERIOD`, that is 1 per ms): this will maintain the same fading smoothness for the LED, regardless of the brightness cycle length, which can be set by the user writing to the character device.

**Brightness cycle**: the period (which, unlike `PWM_PERIOD`, should be visible to the human eye) during which the LED makes a gradual transition from zero brightness to half brightness (the maximum reached with the current code), then back to zero.
